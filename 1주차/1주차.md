## 이 책의 세 가지 주제
* 가상화
* 병행성
* 영속성

## 운영체제 개요
프로그램은 프로그램이 수행해야 할 명령어가 소진될 때까지 초당 수백만~수십억 번 명령어를 **반입(fetch)**, **해석(decode)**, **실행(execute)**<wbr>을 반복하는 과정,
운영체제는 아래처럼 사용자가 프로그램을 더 쉽게 실행하게 도와줌
 - 프로그램의 **실행 제어**
 - 프로그램 간 **메모리 공유**
 - 프로그램과 **장치간 상호작용**

## 운영체제가 하는 일
### 1. **가상화**
물리적 자원을 가상의 형태로 만들어 제공 -> 운영체제를 **'가상머신'**<wbr>이라고도 함
#### 1-1. CPU 가상화
: 실제 CPU는 제한되어 있지만 마치 무한대의 CPU가 제공되어 모든 프로세스가 동시에 실행되는 것처럼 보이게 함
- *시분할(time-sharing)*<wbr>을 통해 CPU를 여러 프로세스에 분할
#### 1-2. 메모리 가상화
: 각 프로세스는 운영체제의 물리 RAM (+ 디스크 스왑) 가상화를 통해 각자의 가상 주소 공간을 사용할 수 있음. 가상 주소 공간은 보호(격리)되지만, 필요시 `공유 메모리`, 동일 파일에 대한 `mmap`, fork 후 `CoW` 등을 통해 동일 물리 프레임을 여러 프로세스가 매핑 가능
- 운영체제 역할: 페이지/프레임 관리(할당, 회수), 페이지 테이블 생성/유지, 권한 비트(R/W/X, user/supervisor 등)로 보호 설정, 페이지 폴트 처리 및 스왑 정책 운영
- MMU(Memory Management Unit): 메모리 접근 시마다 TLB(Translation Lookaside Buffer) + 페이지 테이블을 이용해 가상 주소(VA) -> 물리 주소(PA) 변환
    - TLB: 최근 변환 캐시 -> 대부분의 접근 빠르게 처리
    - TLB 미스: 하드웨어 또는 운영체제가 페이지 테이블을 워크해서 변환 결과를 채워줌

### 2. 병행성과 관련된 복잡한 문제 처리
: 현대 운영체제는 여러 프로세스나 스레드를 동시에 실행시키기 때문에 race condition, deadlock, atomicity 등의 문제가 발생함. 사용자 입장에서는 하나의 명령을 입력하더라도 운영체제는 `메모리 -> 레지스터`, `연산`, `레지스터->메모리` 총 3단계를 거침. 운영체제는 이런 연산들을 원자적으로 보장하도록 **락, 세마포어, 뮤텍스 등을 통한 동기화 처리**를 함

### 3. 파일을 영속적으로 저장
: RAM은 휘발성 메모리이기 때문에 전원이 꺼지면 데이터가 사라짐.
따라서 데이터를 영속화하기 위해서는 **HDD(Hard Disk Drive)**<wbr>나 **SSD(Solid State Drive)**<wbr>같은 비휘발성 저장장치가 필요함. 이렇게 안전하고 효율적인 데이터 영속화를 관리하는 운영체제의 소프트웨어 계층이 바로 **파일 시스템**임

#### 3-1. 데이저 저장과 메타데이터 관리
* 배치 결정(placement): 파일/블록을**디스크의 어느 위치에 저장할지 결정**해야 함
* 메타데이터 구조: inode(파일 속성, 블록 매핑), dentry(디렉터리 인덱스), extents(연속 블록), B+Tree/HTree 등의 다양한 자료구조를 사용해 파일의 위치와 상태를 추적, 최적화함

#### 3-2. 성능 최적화
* 페이지 캐시 & 지연 쓰기(Write-back): 여러 작은 쓰기를 메모리에 모아서 배치로 저장
    - 지연 할당(Delayed Allocation)으로 실제 블록 배치를 늦춰 연속 할당 유도 -> 단편화↓
    - 내구성 보장이 필요할 때는 fsync()/write barrier/flush로 강제 영구화
* 읽기 가속: Read-ahead(선읽기), I/O 스케쥴링/요청 병합으로 탐색 비용 감소
* 메타데이터 캐시: dentry/inode 캐시(RCU 등)으로 파일 조회 지연 최소화

#### 3-3. 데이터 일관성 및 복구
* 파일 시스템은 시스템 오류나 전원 장애가 발생하더라도 파일이 손상되지 않도록 **다양한 복구 기법**을 적용함
    - 저널링: 파일/데이터의 변경을 트랜잭션 단위로 저널(로그)에 선기록하고 커밋 레코드까지 디스크에 영구화한 뒤, 체크포인트 단계에서 원래 위치(홈 블록)에 반영하는 기법. 크래시된 경우 커밋된 트랜잭션만 재생해서 일관성 복구
    - Copy-On-Write: 기존 데이터 블록 원본에 수정하지 않고 변경사항을 새 블록에 먼저 기록한 뒤, 데이터의 포인터를 원자적으로 새 블록을 가리키게 교체해서 커밋하는 기법

#### 3-4. 하부 저장장치의 가용성/성능(RAID)
* RAID0/1/5/6/10로 성능·내고장성을 균형 있게 확보
* RAID0: 스트라이핑(성능↑, 내고장성X)
* RAID1: 미러(읽기 성능/가용성↑)
* RAID5/6: 패리티 기반(용량 효율·내고장성 균형)
* RAID10: 성능+가용성 모두↑

### 4. 시스템 콜 제공
: 유저 프로그램이 운영체제의 기능을 간접적으로 이용할 수 있도록 시스템 콜 제공
시스템 콜은 유저모드 → 커널 모드 전환의 진입점으로 작용하는 인터페이스이기도 함

### 5. 효율적인 공유자원 관리
: CPU, 메모리, 디스크, 네트워크, I/O 장치 등의 공유자원 할당, 회수, 보호, 격리, 스케쥴링을 책임짐 -> 운영체제를 **'자원관리자'**<wbr>라고도 함