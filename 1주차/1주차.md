## 이 책의 세 가지 주제
* 가상화
* 병행성
* 영속성

## 운영체제 개요
프로그램은 프로그램이 수행해야 할 명령어가 소진될 때까지 초당 수백만~수십억 번 명령어를 **반입(fetch)**, **해석(decode)**, **실행(execute)** 을 반복하는 과정,
운영체제는 아래처럼 사용자가 프로그램을 더 쉽게 실행하게 도와줌
 - 프로그램의 **실행 제어**
 - 프로그램 간 **메모리 공유**
 - 프로그램과 **장치간 상호작용**

## 운영체제가 하는 일
### 1. **가상화**
물리적 자원을 가상의 형태로 만들어 제공 -> 운영체제를 **'가상머신'** 이라고도 함
#### 1-1. CPU 가상화
: 실제 CPU는 제한되어 있지만 마치 무한대의 CPU가 제공되어 모든 프로세스가 동시에 실행되는 것처럼 보이게 함
- *시분할(time-sharing)* 을 통해 CPU를 여러 프로세스에 분할
#### 1-2. 메모리 가상화
: 각 프로세스는 운영체제의 물리 RAM (+ 디스크 스왑) 가상화를 통해 각자의 가상 주소 공간을 사용할 수 있음. 가상 주소 공간은 보호(격리)되지만, 필요시 `공유 메모리`, 동일 파일에 대한 `mmap`, fork 후 `CoW` 등을 통해 동일 물리 프레임을 여러 프로세스가 매핑 가능
- 운영체제 역할: 페이지/프레임 관리(할당, 회수), 페이지 테이블 생성/유지, 권한 비트(R/W/X, user/supervisor 등)로 보호 설정, 페이지 폴트 처리 및 스왑 정책 운영
- MMU(Memory Management Unit): 메모리 접근 시마다 TLB(Translation Lookaside Buffer) + 페이지 테이블을 이용해 가상 주소(VA) -> 물리 주소(PA) 변환
    - TLB: 최근 변환 캐시 -> 대부분의 접근 빠르게 처리
    - TLB 미스: 하드웨어 또는 운영체제가 페이지 테이블을 워크해서 변환 결과를 채워줌

### 2. 병행성과 관련된 복잡한 문제 처리
: 현대 운영체제는 여러 프로세스나 스레드를 동시에 실행시키기 때문에 race condition, deadlock, atomicity 등의 문제가 발생함. 사용자 입장에서는 하나의 명령을 입력하더라도 운영체제는 `메모리 -> 레지스터`, `연산`, `레지스터->메모리` 총 3단계를 거침. 운영체제는 이런 연산들을 원자적으로 보장하도록 **락, 세마포어, 뮤텍스 등을 통한 동기화 처리** 를 함

### 3. 파일을 영속적으로 저장
: RAM은 휘발성 메모리이기 때문에 전원이 꺼지면 데이터가 사라짐.
따라서 데이터를 영속화하기 위해서는 **HDD(Hard Disk Drive)** 나 **SSD(Solid State Drive)** 같은 비휘발성 저장장치가 필요함. 이렇게 안전하고 효율적인 데이터 영속화를 관리하는 운영체제의 소프트웨어 계층이 바로 **파일 시스템**임

파일시스템은 파일/데이터를 저장할 때 **디스크의 어느 위치에 저장할지 결정** 해야 함. 이를 위해 파일 시스템은 할당 테이블, inode 등의 다양한 자료구조를 사용해 파일의 위치와 상태를 추적, 관리함

파일 시스템은 시스템 오류나 전원 장애가 발생하더라도 파일이 손상되지 않도록 **다양한 복구 기법** 을 적용함
 - 저널링: 파일/데이터의 변경을 트랜잭션 단위로 저널(로그)에 선기록하고 커밋 레코드까지 디스크에 영구화한 뒤, 체크포인트 단계에서 원래 위치(홈 블록)에 반영하는 기법. 크래시된 경우 커밋된 트랜잭션만 재생해서 일관성 복구
 - Copy-On-Write: 기존 데이터 블록 원본에 수정하지 않고 변경사항을 새 블록에 먼저 기록한 뒤, 데이터의 포인터를 원자적으로 새 블록을 가리키게 교체해서 커밋하는 기법

### 4. 시스템 콜 제공
: 유저 프로그램이 운영체제의 기능을 간접적으로 이용할 수 있도록 시스템 콜 제공
시스템 콜은 유저모드 → 커널 모드 전환의 진입점으로 작용하는 인터페이스이기도 함

### 5. 효율적인 공유자원 관리
: CPU, 메모리, 디스크, 네트워크, I/O 장치 등의 공유자원 할당, 회수, 보호, 격리, 스케쥴링을 책임짐 -> 운영체제를 **'자원관리자'** 라고도 함